// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String         @id @default(cuid())
  email         String         @unique
  name          String?
  createdAt     DateTime       @default(now())
  settings      Json?
  levelEstimate LevelEstimate?
  reviews       Review[]
  lexemeStates  LexemeState[]
  cards         Card[]
  assessmentSessions AssessmentSession[]
  assessmentResponses AssessmentResponse[]
  lexemeAbilities LexemeAbility[]
}

model Lexeme {
  id           String        @id @default(cuid())
  lemma        String
  pos          String?
  freqRank     Int
  cefr         String        // A1..C2 seed label
  forms        String[]      // optional inflections
  notes        String?
  sentences    Sentence[]
  cards        Card[]
  lexemeStates LexemeState[]
  assessmentItems AssessmentItem[]
  assessmentResponses AssessmentResponse[]
  lexemeAbilities LexemeAbility[]

  // Added fields for probabilistic assessment
  familyId          String?
  zipf              Float?
  length            Int?
  morphComplex      Int?      // 0..2 heuristic
  cognate           Boolean?  @default(false)
  falseFriend       Boolean?  @default(false)
  bInitRecognition  Float?
  bInitRecall       Float?

  @@index([freqRank])
  @@index([cefr])
  @@index([zipf])
}

model Sentence {
  id             String   @id @default(cuid())
  targetLexemeId String
  textL2         String
  textL1         String   // translation
  cefr           String
  difficulty     Float    // 0..1 scaled
  tokens         String[] // optional tokenizer output
  source         String   // "llm" | "seed"
  targetForm     String?
  createdAt      DateTime @default(now())
  uniqueHash     String   @unique
  lexeme         Lexeme   @relation(fields: [targetLexemeId], references: [id])
  cards          Card[]
}

model Card {
  id             String   @id @default(cuid())
  userId         String
  sentenceId     String
  targetLexemeId String
  createdAt      DateTime @default(now())
  user           User     @relation(fields: [userId], references: [id])
  sentence       Sentence @relation(fields: [sentenceId], references: [id])
  lexeme         Lexeme   @relation(fields: [targetLexemeId], references: [id])
  reviews        Review[]
}

model Review {
  id          String   @id @default(cuid())
  userId      String
  lexemeId    String
  cardId      String
  rating      Int      // 1 again, 2 hard, 3 good, 4 easy
  reviewedAt  DateTime @default(now())
  stability   Float    // snapshot BEFORE update
  difficulty  Float
  elapsedDays Int
  user        User     @relation(fields: [userId], references: [id])
  card        Card     @relation(fields: [cardId], references: [id])

  @@index([userId, reviewedAt])
}

model LexemeState {
  userId     String
  lexemeId   String
  due        DateTime
  stability  Float
  difficulty Float
  reps       Int
  lapses     Int
  lastReview DateTime?
  suspended  Boolean  @default(false)
  user       User     @relation(fields: [userId], references: [id])
  lexeme     Lexeme   @relation(fields: [lexemeId], references: [id])

  @@id([userId, lexemeId])
  @@index([due])
}

model LevelEstimate {
  userId     String   @id
  cefrBand   String   // A1..C2
  vocabIndex Float    // 0..10
  confidence Float    // 0..1
  updatedAt  DateTime @default(now())
  user       User     @relation(fields: [userId], references: [id])

  // Optional IRT summary
  theta      Float?
  thetaVar   Float?
}

/// Assessment enums and models for IRT/CAT placement

enum AssessmentItemType {
  yesno_real
  yesno_pseudo
  mc4
  recall
}

model AssessmentSession {
  id              String    @id @default(cuid())
  userId          String
  stage           String    // "yesno" | "cat" | "done"
  startedAt       DateTime  @default(now())
  completedAt     DateTime?
  currentTheta    Float     @default(0)
  currentVar      Float     @default(1)
  yesNoCompleted  Boolean   @default(false)
  falseAlarmRate  Float?
  config          Json?

  user            User      @relation(fields: [userId], references: [id])
  items           AssessmentItem[]
  responses       AssessmentResponse[]

  @@index([userId, startedAt])
}

model AssessmentItem {
  id           String               @id @default(cuid())
  sessionId    String
  type         AssessmentItemType
  lexemeId     String?
  pseudoword   String?
  g            Float                // guessing parameter
  b            Float?               // difficulty snapshot used when presented
  exposure     Int                  @default(0)
  presentedAt  DateTime             @default(now())

  session      AssessmentSession    @relation(fields: [sessionId], references: [id])
  lexeme       Lexeme?              @relation(fields: [lexemeId], references: [id])
  responses    AssessmentResponse[]

  @@index([sessionId])
  @@index([lexemeId])
}

model AssessmentResponse {
  id            String            @id @default(cuid())
  sessionId     String
  itemId        String
  lexemeId      String?
  userId        String
  y             Int               // 0 or 1
  respondedAt   DateTime          @default(now())
  responseMs    Int?
  thetaBefore   Float?
  thetaAfter    Float?

  session       AssessmentSession  @relation(fields: [sessionId], references: [id])
  item          AssessmentItem     @relation(fields: [itemId], references: [id])
  lexeme        Lexeme?            @relation(fields: [lexemeId], references: [id])
  user          User               @relation(fields: [userId], references: [id])

  @@index([sessionId, respondedAt])
}

// Optional per-user per-lexeme difficulty overrides
model LexemeAbility {
  userId   String
  lexemeId String
  bHat     Float
  bVar     Float?

  user     User   @relation(fields: [userId], references: [id])
  lexeme   Lexeme @relation(fields: [lexemeId], references: [id])

  @@id([userId, lexemeId])
}
